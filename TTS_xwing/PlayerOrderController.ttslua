-- Scrip created by Eirik 'Flippster' Munthe for the Unified X-Wing 2.0 TTS Module
-- Standard libraries extentions
#include !/TTS_lib/Util/Util

max_rounds = 12
max_offset = 9
state = "init"
history = {}
players = {}
required_dice_roll_players = {}
default_color = color(0.8,0.8,0.8)
stones = {}
runningCounts = {}
indicators = {}
dice_roll_scores = {}
round = 0
even_distribution = false
after_dials_mode = true
dice_roll_mode = false
wait_timer = nil
dice_roll_timer = 0

function onLoad(save_state)
  math.randomseed(os.time())
  if save_state and save_state ~= nil then
      local loadState = JSON.decode(save_state)
      if loadState and loadState ~= {} then
        max_rounds = loadState.max_rounds
        state = loadState.state
        history = loadState.history
        players = loadState.players
        stones = loadState.stones
        round = loadState.round
        even_distribution = loadState.even_distribution
        after_dials_mode = loadState.after_dials_mode
        dice_roll_mode = loadState.dice_roll_mode
        for color, player in pairs(players) do
          required_dice_roll_players[color] = true
        end
      end
  end

  recreateIndicators()
  setContextMenu()
  self.tooltip = false
end


function onSave()
    local sState = {}
    sState.max_rounds = max_rounds
    sState.state = state
    sState.history = history
    sState.players = players
    sState.stones = stones
    sState.round = round
    sState.even_distribution = even_distribution
    sState.after_dials_mode = after_dials_mode
    sState.dice_roll_mode = dice_roll_mode
    return JSON.encode(sState)
end

function setContextMenu()
  self.clearContextMenu()
  if state == "init" then
    self.addContextMenuItem("Register Player", registerPlayer, false)
    self.addContextMenuItem("Start", start, false)
    if even_distribution then
      self.addContextMenuItem("Disable fairness", function() setFairness(false) end, false)
    else
      self.addContextMenuItem("Enable fairness", function() setFairness(true) end, false)
    end
    if dice_roll_mode then
      self.addContextMenuItem("Disable dice Mode", function() setDiceMode(false) end, false)
    else
      self.addContextMenuItem("Enable dice Mode", function() setDiceMode(true) end, false)
    end
  elseif state == "active" and not dice_roll_mode then
    self.addContextMenuItem("Randomize", function() randomizeNext(true) end, false)
    --self.addContextMenuItem("Fill random",function() randomTest(true) end, false)
    --self.addContextMenuItem("Random run",startRandomRun, false)
    self.addContextMenuItem("Set ready", function(player) setReady({set=true,player=player}) end, false)
  end
  self.addContextMenuItem("Reset",reset,false )
end

function setFairness(enabled)
  even_distribution = enabled
  setContextMenu()
  if enabled then
    printToAll("Fair distribution enabled when randomizing first player", {1, 0.4, 0})
  else
    printToAll("Fair distribution disabled when randomizing first player", {1, 0.4, 0})
  end
end

function setDiceMode(enabled)
  dice_roll_mode = enabled
  setContextMenu()
  if enabled then
    printToAll("Dice roll mode enabled for the first player randomiser", {1, 0.4, 0})
  else
    printToAll("Dice roll mode disabled for the first player randomiser", {1, 0.4, 0})
  end
end


function reset()
  state = "init"
  round = 0
  history = {}
  players = {}
  required_dice_roll_players = {}
  max_rounds = 12
  recreateIndicators()
  setContextMenu()
end

function start()
  if table.size(players) < 2 then
    printToAll("Unable to start the first player randomizer, needs at least 2 registered players", {1, 0.4, 0})
    return
  end
  state = "active"
  setContextMenu()
  for color, player in pairs(players) do
    table.insert(stones, color)
    table.insert(stones, color)
    table.insert(stones, color)
  end
  for color, player in pairs(players) do
    required_dice_roll_players[color] = true
  end
  printToAll("The first player randomizer is started", {1, 0.4, 0})

end

function registerPlayer(new_player)
  if players[new_player] then
    printToAll(new_player .. " player allready registered with the first player randomizer", {1, 0.4, 0})
    return
  end
  printToAll(new_player .. " player registered with the first player randomizer", {1, 0.4, 0})
  players[new_player] = {color=new_player, set=false}
end

function recreateIndicators()
  for i, indicator in pairs(indicators) do
    destroyObject(indicator)
  end
  indicators = {}

  self.destroyAttachments()
  local adjusted_max_offset = max_offset
  local scalefactor = 0
  if max_rounds > 12 then
    adjusted_max_offset = adjusted_max_offset + 0.02 * (max_rounds - 12)
    scalefactor = 0.02
    for i = 1, max_rounds - 12, 1
    do
      scalefactor = scalefactor + 0.25*(0.99^i)
    end
  end
  local range = 2*adjusted_max_offset

  for i = 1,max_rounds,1
  do
    local fraction = (i-1) / (max_rounds - 1)
    local offset = adjusted_max_offset - range * fraction
    local indicator = spawnObject({
        type              = "Custom_Model",
        position          = self.positionToWorld(vector(-0.1,0.05, offset)),
        rotation          = self.getRotation() + vector(0,0,45),
        scale             = vector(0.65, 0.65, 0.65) - vector(0.05,0,0.1)*scalefactor,
        sound             = false,
        snap_to_grid      = false,
    })
    indicator.setCustomObject({
        mesh = '{verifycache}https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/models/randomtile.obj',
        convex = true,
        material = 1,
        type = 0
    })

    indicator.UI.setXml('<Text id="IdLabel" resizeTextForBestFit="true" resizeTextMinSize="30" resizeTextMaxSize="70" color="#111111" rotation="180 180 90" position="0 0 -9" height="100" fontSize="50" fontStyle="Bold">' ..tostring(i) .. '</Text>')
    indicator.setName("indicator")
    indicator.setDescription(i)
    indicator.setLock(true)
    indicator.interactable = false
    indicator.addTag("TempLayoutElement")
    if history[i] then
      indicator.setColorTint(history[i])
    else
      indicator.setColorTint(default_color)
    end
    table.insert(indicators, indicator)
  end
end

function setIndicator(index, color)
  indicators[index].setColorTint(color)
end

function randomizeColor()
  if even_distribution then
    local index = math.random(#stones)
    local pick = stones[index]
    table.remove(stones, index)
    if round%table.size(players) == 0 then
      for _, player in pairs(players) do
        table.insert(stones, player.color)
      end
    end
    return pick
  else
    local i = 1
    local pick = math.random(table.size(players))
    for color,player in pairs(players) do
      if i == pick then
        return color
      end
      i = i + 1
    end
    print("Error, picked a value not within player range")
    return Color.White
  end
end

function randomizeNext(verbose)
  round = round + 1
  local color = randomizeColor()
  table.insert(history, color)
  if round > max_rounds then
    max_rounds = round
    recreateIndicators()
  else
    setIndicator(round,color)
  end
  if verbose then
    printToAll("[".. Color.fromString(color):toHex() .. "]" .. color .. "[-] player is first in round " .. tostring(round), {1, 0.4, 0})
  end
  return color
end

function randomTest(verbose)
  round = 0
  local counts = {}
  stones = {}
  for _, player in pairs(players) do
    counts[player.color] = 0
    table.insert(stones, player.color)
    table.insert(stones, player.color)
    table.insert(stones, player.color)
  end
  for i = 1,max_rounds,1
  do
    local color = randomizeNext()
    counts[color] = counts[color] + 1
  end
  if verbose then
    for color, count in pairs(counts) do
      print(tostring(color) .. " "..tostring(count) )
    end
  else
    runningCounts[counts[players[1].color]] = runningCounts[counts[players[1].color]] + 1
  end
end

function startRandomRun()
  runningCounts = {[0]=0,[1]=0,[2]=0,[3]=0,[4]=0,[5]=0,[6]=0,[7]=0,[8]=0,[9]=0,[10]=0,[11]=0,[12]=0}
  Wait.time(randomTest,0.1,100)
  Wait.time(presentRandomResults, 20/2)
end

function presentRandomResults()
  for n,count in pairs(runningCounts) do
    print("c[ " .. tostring(n) .. " ] = " .. tostring(count))
  end
end

function setReady(argTable)
  if argTable.set == true and after_dials_mode then
    if not Global.call('API_IsAllDialsSet', {player=argTable.player}) then

    end
  end
  Wait.stop(wait_timer)
  players[argTable.player].set = argTable.set
  for color, player in pairs(players) do
    if not player.set then
      return
    end
  end
  wait_timer = Wait.time(function() randomizeNext(true) end,3)
end

function firstPlayerRoll(args)
  if dice_roll_mode and state == "active" and required_dice_roll_players[args.color] then
    printToAll("[" .. Color.fromString(args.color):toHex() .. "]" .. args.player .. "[-] rolled for first player", {1, 0.4, 0})
    dice_roll_scores[args.color] = args.score
    if table.size(dice_roll_scores) == table.size(required_dice_roll_players) then
      Wait.stop(dice_roll_timer)
      local highest_score = 0
      local highest_players = {}
      for color, score in pairs(dice_roll_scores) do
        if score > highest_score then
          highest_score = score
          highest_players = {color}
        elseif score == highest_score then
          table.insert(highest_players, color)
        end
      end

      printToAll("All players have rolled for first player.", {1, 0.4, 0})

      if #highest_players > 1 then
        local print_str = "Players;"
        required_dice_roll_players = {}
        for _, color in pairs(highest_players) do
          required_dice_roll_players[color] = true
          print_str = print_str .. " [" .. Color.fromString(color):toHex() .. "]" .. color .. "[-],"
        end
        printToAll(print_str .. " rolled the same result and must reroll their first player dice", {1, 0.4, 0})
        dice_roll_scores = {}
      else
        round = round + 1
        local color = highest_players[1]
        table.insert(history, color)
        if round > max_rounds then
          max_rounds = round
          recreateIndicators()
        else
          setIndicator(round,color)
        end
        printToAll( "[".. Color.fromString(color):toHex() .. "]" .. color .. "[-] player is first in round " .. tostring(round), {1, 0.4, 0})
        dice_roll_scores = {}
      end
    else
      Wait.stop(dice_roll_timer)
      dice_roll_timer = Wait.time(firstPlayerRollTimeout, 30)
    end
  end
end

function firstPlayerRollTimeout()
  printToAll("Automatic detection of first player roll timed out, all players must roll at the same time.", {1, 0.4, 0})
  dice_roll_scores = {}
end
