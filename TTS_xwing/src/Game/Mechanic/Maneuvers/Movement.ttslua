local Dim = require("TTS_xwing.src.Dim")

local igu = Dim.Convert_mm_igu

-- Strategy Design Pattern
-- Base MovementStrategy class
local MovementStrategy = {}
MovementStrategy.__index = MovementStrategy

function MovementStrategy:new()
    return setmetatable({}, self)
end

function MovementStrategy:execute(ship)
    -- To be overridden by subclasses
end

function MovementStrategy:getBaseSize(ship)
    local shipData = ship.getTable("Data")
    local size = shipData.Size or "small"
    return igu(Dim.mm_baseSize[size])
end

--[[
If the forward Vector of the object doesn't line up with the object
visually, you can attach an angle value here to correct the forward vector
by rotating it around the y-axis by the provided angle in degrees.
This will allow object's forward vector to move it properly.
 ]]
function MovementStrategy:getForwardVector(ship)
    local forward = ship.getTransformForward()
    local shipData = ship.getTable("Data")
    local forwardAdjustment = shipData.forwardAdjustment or 0
    forward = forward:rotateOver("y", forwardAdjustment)
    return forward:normalized()
end

-- StraightMove class inherits from MovementStrategy
local StraightMove = setmetatable({}, { __index = MovementStrategy })
StraightMove.__index = StraightMove

function StraightMove:new(distance)
    local instance = MovementStrategy:new()
    instance.distance = igu(distance)
    return setmetatable(instance, StraightMove)
end

function StraightMove:execute(ship)
    local forward = self:getForwardVector(ship)
    local baseSize = self:getBaseSize(ship)
    local posDelta = (self.distance + baseSize) * forward
    local newPos = ship.getPosition() + posDelta
    ship.setPositionSmooth(newPos, false, true)
end

-- KoiogranTurn class inherits from StraightMove
local KoiogranTurn = setmetatable({}, { __index = StraightMove })
KoiogranTurn.__index = KoiogranTurn

function KoiogranTurn:new(distance)
    local instance = StraightMove:new(distance) -- Properly initialize distance
    instance.rotation = 180
    return setmetatable(instance, KoiogranTurn)
end

function KoiogranTurn:execute(ship)
    StraightMove:execute(ship)
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.rotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- Moves along a curved path
local ArcMove = setmetatable({}, { __index = MovementStrategy })
ArcMove.__index = ArcMove

function ArcMove:new(radius, angle, direction)
    local instance = MovementStrategy:new()
    instance.radius = igu(radius)
    instance.angle = angle
    instance.direction = direction or "right" -- Default to right if no direction is provided
    return setmetatable(instance, ArcMove)
end

function ArcMove:execute(ship)
    local forward = self:getForwardVector(ship)
    -- Determine the sign for the angle based on direction
    local angleMultiplier = self.direction == "left" and 1 or -1
    local adjustedAngle = self.angle * angleMultiplier

    local directionToCenter = forward:copy():rotateOver("y", angleMultiplier * 90):normalized()

    local baseSize = self:getBaseSize(ship)

    -- Calculate the center of the arc
    local centerOfArc = ship.getPosition() - directionToCenter * (self.radius + baseSize)

    -- Calculate the angle in radians
    local angleRadians = math.rad(adjustedAngle)

    -- Calculate the new position using trigonometry
    local cosAngle = math.cos(angleRadians)
    local sinAngle = math.sin(angleRadians)
    local offsetX = (ship.getPosition().x - centerOfArc.x) * cosAngle - (ship.getPosition().z - centerOfArc.z) * sinAngle
    local offsetZ = (ship.getPosition().x - centerOfArc.x) * sinAngle + (ship.getPosition().z - centerOfArc.z) * cosAngle
    local newPos = Vector(centerOfArc.x + offsetX, ship.getPosition().y, centerOfArc.z + offsetZ)

    -- Determine the new rotation
    -- local spin = forward:cross(directionToCenter):dot(Vector(0, 1, 0))
    local spin = angleMultiplier * directionToCenter:cross(forward):dot(Vector(0, 1, 0))

    local newRotation = ship.getRotation() + Vector(0, spin * adjustedAngle, 0)

    -- Update ship position and rotation smoothly
    ship.setPositionSmooth(newPos, false, false)
    ship.setRotationSmooth(newRotation, false, false)
end

-- TurnMove class inherits from ArcMove
local TurnMove = setmetatable({}, { __index = ArcMove })
TurnMove.__index = TurnMove

function TurnMove:new(radius, direction)
    return setmetatable(ArcMove:new(radius, 90, direction), TurnMove)
end

-- BankMove class inherits from ArcMove
local BankMove = setmetatable({}, { __index = ArcMove })
BankMove.__index = BankMove

function BankMove:new(radius, direction)
    return setmetatable(ArcMove:new(radius, 45, direction), BankMove)
end

-- SegnorLoop class inherits from ArcMove
local SegnorLoop = setmetatable({}, { __index = ArcMove })
SegnorLoop.__index = SegnorLoop

function SegnorLoop:new(radius, direction, rotation)
    local instance = ArcMove:new(radius, 45, direction) -- Using 45 degrees as the bank angle
    instance.rotation = rotation or 180                 -- Defaulting to a 180-degree rotation
    return setmetatable(instance, SegnorLoop)
end

function SegnorLoop:execute(ship)
    ArcMove:execute(ship)
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.rotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- TallonRoll class inherits from ArcMove
local TallonRoll = setmetatable({}, { __index = ArcMove })
TallonRoll.__index = TallonRoll

function TallonRoll:new(radius, direction, extraRotation)
    local instance = ArcMove:new(radius, 90, direction) -- Using 90 degrees as the bank angle
    instance.extraRotation = extraRotation or -90       -- Defaulting to a 90-degree additional rotation
    return setmetatable(instance, TallonRoll)
end

function TallonRoll:execute(ship)
    ArcMove:execute(ship)
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.extraRotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- Main Movement class
local Movement = {}
Movement.__index = Movement

-- Define the moveStrategies table once, outside of the constructor
Movement.moveStrategies = {
    -- Straight maneuvers
    s1 = StraightMove:new(40),
    s2 = StraightMove:new(80),
    s3 = StraightMove:new(120),
    s4 = StraightMove:new(160),
    s5 = StraightMove:new(200),

    -- Koiogran Turn (180ยบ turn using the same template as the straight maneuver)
    k1 = KoiogranTurn:new(40),
    k2 = KoiogranTurn:new(80),
    k3 = KoiogranTurn:new(120),
    k4 = KoiogranTurn:new(160),
    k5 = KoiogranTurn:new(200),

    -- Turn maneuvers
    tr1 = TurnMove:new(35, "right"),
    tr2 = TurnMove:new(63, "right"),
    tr3 = TurnMove:new(90, "right"),

    tl1 = TurnMove:new(35, "left"),
    tl2 = TurnMove:new(63, "left"),
    tl3 = TurnMove:new(90, "left"),

    -- Bank maneuvers
    br1 = BankMove:new(80, "right"),
    br2 = BankMove:new(130, "right"),
    br3 = BankMove:new(180, "right"),

    bl1 = BankMove:new(80, "left"),
    bl2 = BankMove:new(130, "left"),
    bl3 = BankMove:new(180, "left"),

    -- Segnor's Loop (uses the bank template and reverses facing)
    br1s = SegnorLoop:new(80, "right", 180),
    br2s = SegnorLoop:new(130, "right", 180),
    br3s = SegnorLoop:new(180, "right", 180),

    bl1s = SegnorLoop:new(80, "left", 180),
    bl2s = SegnorLoop:new(130, "left", 180),
    bl3s = SegnorLoop:new(180, "left", 180),

    -- Tallon Roll (uses the turn template and rotates the ship 90ยบ at the end)
    tr1tl = TallonRoll:new(35, "right", -90),
    tr2tl = TallonRoll:new(63, "right", -90),
    tr3tl = TallonRoll:new(90, "right", -90),

    tl1tl = TallonRoll:new(35, "left", -90),
    tl2tl = TallonRoll:new(63, "left", -90),
    tl3tl = TallonRoll:new(90, "left", -90),
}

function Movement:new()
    local instance = setmetatable({}, self)
    instance.moveStrategies = self.moveStrategies
    return instance
end

function Movement:Move(ship, moveType)
    local moveStrategy = self.moveStrategies[moveType]
    if ship and moveStrategy then
        moveStrategy:execute(ship)
    else
        print("Invalid: ship: " .. tostring(ship) .. " with move type: " .. moveType)
    end
end

return Movement
