local Dim = require("TTS_xwing.src.Dim")

local igu = Dim.Convert_mm_igu

-- Strategy Design Pattern
-- Base MovementStrategy class
local MovementStrategy = {}
MovementStrategy.__index = MovementStrategy

function MovementStrategy:new()
    return setmetatable({}, self)
end

function MovementStrategy:execute(ship, forward)
    -- To be overridden by subclasses
end

function MovementStrategy:getBaseSize(ship)
    local shipData = ship.getTable("Data")
    local size = shipData.Size or "small"
    return igu(Dim.mm_baseSize[size])
end

-- StraightMove class inherits from MovementStrategy
local StraightMove = setmetatable({}, { __index = MovementStrategy })
StraightMove.__index = StraightMove

function StraightMove:new(distance)
    local instance = MovementStrategy:new()
    instance.distance = igu(distance)
    return setmetatable(instance, StraightMove)
end

function StraightMove:execute(ship, forward)
    local baseSize = self:getBaseSize(ship)
    local posDelta = (self.distance + baseSize) * forward
    local newPos = ship.getPosition() + posDelta
    ship.setPositionSmooth(newPos, false, true)
end

-- KoiogranTurn class inherits from StraightMove
local KoiogranTurn = setmetatable({}, { __index = StraightMove })
KoiogranTurn.__index = KoiogranTurn

function KoiogranTurn:new(distance)
    local instance = StraightMove:new(distance) -- Properly initialize distance
    instance.rotation = 180
    return setmetatable(instance, KoiogranTurn)
end

function KoiogranTurn:execute(ship, forward)
    StraightMove.execute(self, ship, forward) -- Call the base execute method with the forward vector
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.rotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- Moves along a curved path
local ArcMove = setmetatable({}, { __index = MovementStrategy })
ArcMove.__index = ArcMove

function ArcMove:new(radius, angle)
    local instance = MovementStrategy:new()
    instance.radius = igu(radius)
    instance.angle = angle
    return setmetatable(instance, ArcMove)
end

function ArcMove:execute(ship, forward)
    -- local right = ship.getTransformRight()
    local right = -1 * forward

    local baseSize = self:getBaseSize(ship)

    -- Calculate the center of the arc
    local centerOfArc = ship.getPosition() - right * (self.radius + baseSize)

    -- Calculate the angle in radians
    local angleRadians = math.rad(self.angle)

    -- Calculate the new position using trigonometry
    local cosAngle = math.cos(angleRadians)
    local sinAngle = math.sin(angleRadians)
    local offsetX = (ship.getPosition().x - centerOfArc.x) * cosAngle - (ship.getPosition().z - centerOfArc.z) * sinAngle
    local offsetZ = (ship.getPosition().x - centerOfArc.x) * sinAngle + (ship.getPosition().z - centerOfArc.z) * cosAngle
    local newPos = Vector(centerOfArc.x + offsetX, ship.getPosition().y, centerOfArc.z + offsetZ)

    -- Determine the new rotation
    local newRotation = ship.getRotation() + Vector(0, self.angle, 0)

    -- Update ship position and rotation smoothly
    ship.setPositionSmooth(newPos, false, false)
    ship.setRotationSmooth(newRotation, false, false)
end

-- TurnMove class inherits from ArcMove
local TurnMove = setmetatable({}, { __index = ArcMove })
TurnMove.__index = TurnMove

function TurnMove:new(radius)
    return setmetatable(ArcMove:new(radius, 90), TurnMove)
end

-- BankMove class inherits from ArcMove
local BankMove = setmetatable({}, { __index = ArcMove })
BankMove.__index = BankMove

function BankMove:new(radius)
    return setmetatable(ArcMove:new(radius, 45), BankMove)
end

-- SegnorLoop class inherits from ArcMove
local SegnorLoop = setmetatable({}, { __index = ArcMove })
SegnorLoop.__index = SegnorLoop

function SegnorLoop:new(radius, rotation)
    local instance = ArcMove:new(radius, 45) -- Using 45 degrees as the bank angle
    instance.rotation = rotation or 180      -- Defaulting to a 180-degree rotation
    return setmetatable(instance, SegnorLoop)
end

function SegnorLoop:execute(ship, forward)
    ArcMove:execute(ship, forward)
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.rotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- TallonRoll class inherits from ArcMove
local TallonRoll = setmetatable({}, { __index = ArcMove })
TallonRoll.__index = TallonRoll

function TallonRoll:new(radius, extraRotation)
    local instance = ArcMove:new(radius, 90)      -- Using 90 degrees as the turn angle
    instance.extraRotation = extraRotation or -90 -- Defaulting to a 90-degree additional rotation
    return setmetatable(instance, TallonRoll)
end

function TallonRoll:execute(ship, forward)
    ArcMove:execute(ship, forward)
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.extraRotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- Main Movement class
local Movement = {}
Movement.__index = Movement

--[[
If the forward Vector of the object doesn't line up with the object visually,
you can pass a Vector here that correct the forward vector by rotating it around the y-axis by
 the provided angle in degrees.
This will allow object's forward vector to move it properly.
]]
function Movement:new(forwardAdjustment)
    local instance = setmetatable({}, self)

    -- Store the forwardAdjustment angle, defaulting to 0, if not provided
    instance.forwardAdjustment = forwardAdjustment or 0

    -- Initialize movement strategies once and store them in a table
    instance.moveStrategies = {
        -- Straight maneuvers
        s1 = StraightMove:new(40),
        s2 = StraightMove:new(80),
        s3 = StraightMove:new(120),
        s4 = StraightMove:new(160),
        s5 = StraightMove:new(200),

        -- Koiogran Turn (180ยบ turn using the same template as the straight maneuver)
        k1 = KoiogranTurn:new(40),
        k2 = KoiogranTurn:new(80),
        k3 = KoiogranTurn:new(120),
        k4 = KoiogranTurn:new(160),
        k5 = KoiogranTurn:new(200),

        -- Turn maneuvers
        tr1 = TurnMove:new(35),
        tr2 = TurnMove:new(63),
        tr3 = TurnMove:new(90),

        -- Bank maneuvers
        br1 = BankMove:new(80),
        br2 = BankMove:new(130),
        br3 = BankMove:new(180),

        -- Segnor's Loop (uses the bank template and reverses facing)
        br1s = SegnorLoop:new(80, 180),  -- Left Segnor's Loop
        br2s = SegnorLoop:new(130, 180), -- Right Segnor's Loop
        br3s = SegnorLoop:new(180, 180), -- Right Segnor's Loop

        -- Tallon Roll (uses the turn template and rotates the ship 90ยบ at the end)
        tr1tl = TallonRoll:new(35, -90), -- Right Tallon Roll
        tr2tl = TallonRoll:new(63, -90),
        tr3tl = TallonRoll:new(90, -90)
    }

    return instance
end

function Movement:getForwardVector(ship)
    local forward = ship.getTransformForward()
    forward = forward:rotateOver("y", self.forwardAdjustment)
    return forward:normalized()
end

function Movement:Move(ship, moveType)
    local moveStrategy = self.moveStrategies[moveType]
    if moveStrategy then
        moveStrategy:execute(ship, self:getForwardVector(ship))
    else
        print("Invalid move type: " .. moveType)
    end
end

return Movement
