local Dim = require("TTS_xwing.src.Dim")

local igu = Dim.Convert_mm_igu
-- TODO: check template speed distances: straights, and banks etc.
-- TODO: add reverse move, and reverse bank
-- TODO: internalize the move-1 templates instead of mm
-- TODO: ship size specified in mm or shirt sizes

----------------------------------------
-- Standard X-Wing Maneuver Templates --
----------------------------------------

local XWingTemplates = {
    straight = { 40, 80, 120, 160, 200 },
    turn = { 35, 63, 90 },
    bank = { 80, 130, 180 }
}

-----------------------------
-- Strategy Design Pattern --
-----------------------------

-- Base MovementStrategy class
local ManeuverStrategy = {}
ManeuverStrategy.__index = ManeuverStrategy

function ManeuverStrategy:new()
    return setmetatable({}, self)
end

function ManeuverStrategy:execute(ship)
    -- To be overridden by subclasses
end

function ManeuverStrategy:getBaseSize(ship)
    local shipData = ship.getTable("Data")
    local size = shipData.Size or "small"
    return igu(Dim.mm_baseSize[size])
end

--[[
    If the forward Vector of the object doesn't line up with the object
    visually, you can attach an angle value here to correct the forward vector
    by rotating it around the y-axis by the provided angle in degrees.
    This will allow object's forward vector to move it properly.
 ]]
function ManeuverStrategy:getForwardVector(ship)
    local shipData = ship.getTable("Data")
    local forwardAdjustment = shipData.forwardAdjustment or 0
    local forward = ship.getTransformForward():copy()
    forward = forward:rotateOver("y", forwardAdjustment)
    return forward:normalized()
end

-- StraightMove class inherits from MovementStrategy
local Straight = setmetatable({}, { __index = ManeuverStrategy })
Straight.__index = Straight

function Straight:new(speed)
    local instance = ManeuverStrategy:new()
    instance.speed = igu(XWingTemplates.straight[speed])
    return setmetatable(instance, self)
end

function Straight:execute(ship)
    local forward = self:getForwardVector(ship)
    local baseSize = self:getBaseSize(ship)
    local posDelta = (self.speed + baseSize) * forward
    local newPos = ship.getPosition() + posDelta
    ship.setPositionSmooth(newPos, false, true)
end

-- KoiogranTurn class inherits from StraightMove
local KoiogranTurn = setmetatable({}, { __index = Straight })
KoiogranTurn.__index = KoiogranTurn

function KoiogranTurn:new(speed)
    local instance = Straight:new(speed)
    instance.rotation = 180
    return setmetatable(instance, self)
end

function KoiogranTurn:execute(ship)
    Straight.execute(self, ship)
    local currentRotation = ship.getRotation()
    local newRotation = currentRotation + Vector(0, self.rotation, 0)
    ship.setRotationSmooth(newRotation, false, false)
end

-- Moves along a curved path
local ArcMove = setmetatable({}, { __index = ManeuverStrategy })
ArcMove.__index = ArcMove

function ArcMove:new(radius, angle, bearing, extraRot)
    local instance = ManeuverStrategy:new()
    instance.radius = igu(radius)
    instance.angle = angle
    instance.bearing = bearing or "right" -- Default to right if no bearing is provided
    instance.extraRotation = extraRot or 0
    return setmetatable(instance, self)
end

function ArcMove:execute(ship)
    local sign = self.bearing == "right" and 1 or -1 -- + is clockwise, - is counter-clockwise
    local turnAngle = sign * self.angle
    local rotAngle = sign * (self.angle + self.extraRotation)

    -- Get ship's forward vector and base size
    local forward = self:getForwardVector(ship)
    local turnDirection = sign * forward:copy():rotateOver("y", 90):normalized()

    -- Calculate the center of the arc
    local arcRadius = self.radius + self:getBaseSize(ship) / 2
    local arcCenter = ship.getPosition() + turnDirection * arcRadius

    -- Calculate the new position by rotating the position vector around the arc center
    local newPos = arcCenter + (ship.getPosition() - arcCenter):rotateOver("y", turnAngle)
    local newRot = Vector(0, rotAngle, 180)

    -- Update ship position and rotation smoothly
    ship.setPositionSmooth(newPos, false, false)
    ship.setRotationSmooth(newRot, false, false)
end

-- https://raw.githubusercontent.com/JohnnyCheese/TTS_X-Wing2.0/master/assets/Items/tokens/devices/Mandos.png?1
-- TurnMove class inherits from ArcMove
local TurnMove = setmetatable({}, { __index = ArcMove })
TurnMove.__index = TurnMove

function TurnMove:new(speed, bearing)
    return setmetatable(ArcMove:new(XWingTemplates.turn[speed], 90, bearing), self)
end

-- BankMove class inherits from ArcMove
local BankMove = setmetatable({}, { __index = ArcMove })
BankMove.__index = BankMove

function BankMove:new(speed, bearing)
    return setmetatable(ArcMove:new(XWingTemplates.bank[speed], 45, bearing), self)
end

-- SegnorLoop class inherits from ArcMove
local SegnorLoop = setmetatable({}, { __index = ArcMove })
SegnorLoop.__index = SegnorLoop

function SegnorLoop:new(speed, bearing)
    local instance = ArcMove:new(XWingTemplates.bank[speed], 45, bearing, 180) -- Using 45 degrees as the bank angle
    return setmetatable(instance, self)
end

-- TallonRoll class inherits from ArcMove
local TallonRoll = setmetatable({}, { __index = ArcMove })
TallonRoll.__index = TallonRoll

function TallonRoll:new(speed, bearing)
    local instance = ArcMove:new(XWingTemplates.turn[speed], 90, bearing, 90)
    -- instance.extraRotation = extraRotation or -90
    return setmetatable(instance, self)
end

-- Main Movement class
local Maneuver = {}
Maneuver.__index = Maneuver

-- Define the moveStrategies table once, outside of the constructor
Maneuver.moveStrategies = {
    -- Straight maneuvers
    s1 = Straight:new(1),
    s2 = Straight:new(2),
    s3 = Straight:new(3),
    s4 = Straight:new(4),
    s5 = Straight:new(5),

    -- Koiogran Turn (180ยบ turn using the same template as the straight maneuver)
    k1 = KoiogranTurn:new(1),
    k2 = KoiogranTurn:new(2),
    k3 = KoiogranTurn:new(3),
    k4 = KoiogranTurn:new(4),
    k5 = KoiogranTurn:new(5),

    -- Turn maneuvers
    tr1 = TurnMove:new(1, "right"),
    tr2 = TurnMove:new(2, "right"),
    tr3 = TurnMove:new(3, "right"),

    tl1 = TurnMove:new(1, "left"),
    tl2 = TurnMove:new(2, "left"),
    tl3 = TurnMove:new(3, "left"),

    -- Bank maneuvers
    br1 = BankMove:new(1, "right"),
    br2 = BankMove:new(2, "right"),
    br3 = BankMove:new(3, "right"),

    bl1 = BankMove:new(1, "left"),
    bl2 = BankMove:new(2, "left"),
    bl3 = BankMove:new(3, "left"),

    -- Segnor's Loop
    br1s = SegnorLoop:new(1, "right"),
    br2s = SegnorLoop:new(2, "right"),
    br3s = SegnorLoop:new(3, "right"),

    bl1s = SegnorLoop:new(1, "left"),
    bl2s = SegnorLoop:new(2, "left"),
    bl3s = SegnorLoop:new(3, "left"),

    -- Tallon Roll
    tr1tl = TallonRoll:new(1, "right"),
    tr2tl = TallonRoll:new(2, "right"),
    tr3tl = TallonRoll:new(3, "right"),

    tl1tl = TallonRoll:new(1, "left"),
    tl2tl = TallonRoll:new(2, "left"),
    tl3tl = TallonRoll:new(3, "left"),
}

function Maneuver:new()
    local instance = setmetatable({}, self)
    instance.moveStrategies = self.moveStrategies
    return instance
end

function Maneuver:Move(ship, moveType)
    local moveStrategy = self.moveStrategies[moveType]
    if ship and moveStrategy then
        moveStrategy:execute(ship)
    else
        print("Invalid: ship: " .. tostring(ship) .. " with move type: " .. moveType)
    end
end

return Maneuver
