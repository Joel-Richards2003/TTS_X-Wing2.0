require("TTS_lib.Util.Table")
Sequence = require("TTS_xwing.src.Test.Sequence")
ButtonTest = require("TTS_xwing.src.Test.ButtonTest")
Dim = require("TTS_xwing.src.Dim")

local SmokeTest = {}

SmokeTest.runSmokeTest = function()
    printToAll("Starting Smoke Test...", { 0, 1, 0 })

    local blueInfo = getPlayerHandZoneInfo(Player["Blue"])
    local redInfo = getPlayerHandZoneInfo(Player["Red"])
    local yellowInfo = getPlayerHandZoneInfo(Player["Yellow"])
    local brownInfo = getPlayerHandZoneInfo(Player["Brown"])

    local seq = Sequence:new()

    SmokeTest.spawnImperialShips(seq, Color.Blue, blueInfo.position, blueInfo.rotationOffset)
    SmokeTest.spawnRebelShips(seq, Color.Red, redInfo.position, redInfo.rotationOffset)

    seq:start()

    printToAll("Smoke Test Completed.", { 0, 1, 0 })
end

function SmokeTest.spawnImperialShips(seq, player_color, targetPosition, rotDegrees)
    local dataPad = getObjectFromGUID("a4dbbf")
    if dataPad == nil then
        printToAll("Didn't find DataPad", { 0, 1, 0 })
        return
    end

    seq:add(ButtonTest.Click, dataPad, 'Builder', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Imperial', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Add Ship', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'TIE/ln Fighter', player_color, false)
    seq:add(ButtonTest.Click, dataPad, '"Howlrunner"%s*%(%d+%)', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Add Ship', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'TIE Advanced x1', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Darth Vader%s*%(%d+%)', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Spawn List', player_color, false)
    seq:add(waitAndMove, targetPosition, rotDegrees, 120)
    seq:add(function(seq)
        Wait.frames(function()
            dropDials(seq)
        end, 120)
    end)
end

function SmokeTest.spawnRebelShips(seq, player_color, targetPosition, rotDegrees)
    local dataPad = getObjectFromGUID("a4dbbf")
    if dataPad == nil then
        printToAll("Didn't find DataPad", { 0, 1, 0 })
        return
    end

    seq:add(ButtonTest.Click, dataPad, 'Builder', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Rebel', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Add Ship', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Y%-Wing', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Gray Squadron Bomber%s*%(%d+%)', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Add Ship', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'X%-Wing', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Luke Skywalker%sRed Five%s*%(%d+%)', player_color, false)
    seq:add(ButtonTest.Click, dataPad, 'Spawn List', player_color, false)
    seq:add(waitAndMove, targetPosition, rotDegrees, 120)
end

-- Utility function to get player hand zone info
function getPlayerHandZoneInfo(player)
    local handTransform = player.getHandTransform()
    local position = handTransform.position + handTransform.forward * 19
    local rotationOffset = getRotationOffset(handTransform.forward)
    return {
        position = position,
        rotationOffset = rotationOffset
    }
end

-- Function to calculate the rotation offset based on the forward vector
function getRotationOffset(forwardVector)
    local worldForward = Vector(0, 0, 1)
    local dotProduct = forwardVector:dot(worldForward)
    local angle = math.deg(math.acos(dotProduct))

    -- Determine the sign of the angle based on the cross product
    local crossProduct = forwardVector:cross(worldForward)
    if crossProduct.y < 0 then
        angle = -angle
    end

    return angle - 90
end

-- Helper function to perform movement after a delay
function waitAndMove(seq, targetPosition, rotDegrees, delay)
    Wait.frames(function()
        movement(targetPosition, rotDegrees)
        seq:next()
    end, delay)
end

dropDials = function(seq)
    printToAll("dropDials:")
    seq = seq or Sequence.NoSeq()
    local toShip = { 0, 5, -3 }
    for _, dial in ipairs(getObjects()) do
        if dial.getName() == "Unassigned Dial" then
            dial.translate(toShip)
            Wait.condition(function ()
                assignNearestShip(dial, Color.Blue:toString())
            end, function ()
                return dial.resting
            end)
        end
    end
    Wait.frames(function()
        printToAll("Done waiting")
        seq:next()
    end, 120)
end

-- Function to assign the dial to the nearest ship
assignNearestShip = function(dial, playerColor)
    if dial == nil then
        printToAll("dial is nil", Color.Orange)
        return
    end
    if playerColor == nil then
        printToAll("color is nil", Color.Orange)
        return
    end
    local spos = dial.getPosition()
    local nearest = nil
    local minDist = Dim.Convert_mm_igu(80)
    for _, ship in pairs(getObjects()) do
        if ship.tag == 'Figurine' and ship.name ~= '' then
            local pos = ship.getPosition()
            local dist = math.sqrt(math.pow((spos[1] - pos[1]), 2) + math.pow((spos[3] - pos[3]), 2))
            -- local dist = spos:distance(pos)
            if dist < minDist then
                nearest = ship
                minDist = dist
            end
        end
    end

    if nearest ~= nil then
        if playerColor == "White" then
            printToAll("Please, pick a color before assigning dials")
        else
            local playerTeam = nil
            local teamVisibility = ""
            for _, player in pairs(Player.getPlayers()) do
                if player.color == playerColor then
                    if player.team ~= "None" then
                        playerTeam = player.team
                        teamVisibility = "|" .. playerTeam
                    end
                end
            end

            nearest.setVar('owningPlayer', playerColor)
            printToAll('Dial assigned to ' .. nearest.getName(), { 0.3, 0.3, 1 })
            dial.setRotation(nearest.getRotation())
            dial.call("assignShip", { ship = nearest })
        end
    end
end


-- Function to calculate the centroid of a group of objects
-- TODO: move this into Transform
function calculateCentroid(objects)
    local sum = Vector(0, 0, 0)
    for _, obj in ipairs(objects) do
        sum = sum + obj.getPosition()
    end
    return sum:scale(1.0 / #objects)
end

-- Function to rotate a point around the Y-axis by a given angle
-- TODO: move this into Transform
function rotatePointAroundY(point, origin, angle)
    local rad = math.rad(angle)
    local cos = math.cos(rad)
    local sin = math.sin(rad)
    local relativePos = point - origin

    local rotatedPos = Vector(
        cos * relativePos.x - sin * relativePos.z,
        point.y,
        sin * relativePos.x + cos * relativePos.z
    ) + origin

    return rotatedPos
end

-- Function to move and rotate objects relative to a reference point
-- TODO: move this into Transform
function moveAndRotateGroup(objects, target, rotationOffset)
    if #objects == 0 then
        return
    end

    local centroid = calculateCentroid(objects)

    for _, obj in ipairs(objects) do
        -- Rotate the object around the centroid
        local pos = obj.getPosition()
        local rotatedPos = rotatePointAroundY(pos, centroid, rotationOffset)

        -- Calculate the new position relative to the target
        local newPos = target + (rotatedPos - centroid)

        obj.setPositionSmooth(newPos)

        -- Adjust the rotation based on the centroid and rotationOffset
        local rot = obj.getRotation()
        local newRot = {
            x = rot.x,
            y = 180 - rot.y - rotationOffset,
            z = rot.z,
        }
        obj.setRotationSmooth(newRot, false, false)
    end
end

-- Function to handle the movement and rotation of objects
function movement(targetPosition, rotationOffset)
    -- Define the box for Physics.cast
    local box = {
        origin = Vector(-64.00, 0.0, -30.00), -- Start below the objects
        direction = Vector(0, 0, 1),          -- Move in the positive z-direction
        type = 3,
        size = Vector(13, 10, 5),             -- Extend in the x, y, and z dimensions
        orientation = Vector(0, 0, 0),
        max_distance = 30,
        debug = true,
    }

    -- Perform the cast
    local castResult = Physics.cast(box)

    -- Filter out moveable objects
    local newObjects = {}
    for _, hit_result in ipairs(castResult) do
        local obj = hit_result.hit_object
        if obj.locked == false and obj.interactable == true then
            table.insert(newObjects, obj)
        end
    end

    -- Apply move and rotate to all new objects as a group
    moveAndRotateGroup(newObjects, targetPosition, rotationOffset)
end

return SmokeTest
